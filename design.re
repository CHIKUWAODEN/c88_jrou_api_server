= 設計を考える

//read{
まずは設計を考えていきます。
Web アプリケーションの開発を嗜む人から見れば少々退屈な内容かもしれませんが、お付き合いください。
そもそも Web API における設計というと、具体的にどのようなものでしょうか。
本書では Web API は URI を指定して、HTTP を経由してリクエストされるという根本的な点に注目してみようと思います。
//}


== おおざっぱに決めなくちゃならないこと

Web API オンリーの実装を前提として

どのプログラム言語で書くか
データベース
API の URI




== URI（Uniform Resource Identifier）

URI（Uniform Resource Identifier）はその名が表すとおり、インターネット上のリソースの有りかを示すものです。
つまり、Web API とはリソースそのものであると考えることができると思います。


== HTTP（Hyper Text Transfer Protocol）

もう一つ、HTTP@<fn>{http11_rfc} というものについて触れてみます。
HTTP（Hyper Text Transfer Protocol）はインターネット上でサーバとクライアントが文書（データ）をやりとりするためのプロトコルです。

この HTTP の仕組みを簡単に説明するとともに、
このプロトコル上でどのように Web API といったものを作っていくかという視点で進めていきます。

//footnote[http11_rfc][RFC2616 : https://www.ietf.org/rfc/rfc2616.txt]

=== リクエストメソッド

ここでリクエストメソッドという言葉が出てきました。
リクエストメソッドには次のような種類があり、「サーバに対してどのような動機でリクエストを行ったか」を表します。
本書を執筆している時点でもっとも多くされているであろう HTTP 1.1 という仕様では、次のようなリクエストメソッドが定義されています。


//table[http_req_methods][HTTP 1.1 のリクエストメソッド]{
メソッド        意味
-------------------------------------------------------------------------------
GET						  リソースの取得
POST						リソースの新規作成
PUT						  リソースの更新
HEAD						リソースの
DELETE					リソースの削除
OPTION					リソースの
TRACE					  リソースの
CONNECT				  リソースの
//}


=== レスポンス

Web サーバに対してリクエストを行うと、その応答としてレスポンスを返します。
レスポンスには、サーバが返すデータと、そのリクエストに対してどのような応答をしたかを表すステータスコードというものが含まれています。



== あらためて、Web APIの設計について

== 二郎をリソースという概念で表現する

まず二郎のもつ性質について分析しましょう。
一口に二郎といってもさまざまです。まず店舗という単位が存在し、それらには「店名」「住所」といった普遍的なプロパティを持ちます。
ついで「量」であるとか「スープの質」「価格」「メニュー」「席数」といった点からも分類することが可能でしょう。
これらを踏まえた上で、JSON フォーマットでどのように二郎を表現すれば良いのか考えてみます。


//list[jirou_json_format][ラーメン二郎のデータを JSON フォーマットで表現する][json]{
{
  "shop_name" : "ラーメン二郎 歌舞伎町店",
  "open"      : "11:30",
  "last"      : "04:30",
  "regular_holiday" : []
  "address" : {
    "prefecture"  : "東京都",
    "city"        : "新宿区",
    "address1"    : "歌舞伎町",
    "address2"    : "1-19-3",
    "postal_code" : "160-0021"
  },
  "menues" : [
    { "name" : "普通盛"                 , "price" : 700  },
    { "name" : "チャーシュー"           , "price" : 800  },
    { "name" : "チャーシューダブル"     , "price" : 900  },
    { "name" : "大盛"                   , "price" : 800  },
    { "name" : "大盛チャーシュー"       , "price" : 900  },
    { "name" : "大盛チャーシューダブル" , "price" : 1000 },
    { "name" : "つけ麺普通"             , "price" : 800  },
    { "name" : "つけ麺大盛"             , "price" : 900  },
    { "name" : "キムチ"                 , "price" : 200  },
    { "name" : "煮玉子"                 , "price" : 100  }
  ],
  "estimation" : {
    "buta" : 5.0,
    "men"  : 5.0,
    "soup" : 5.0
  }
  "created"   : "Fri Jun 12 23:03:50 JST 2015",
  "modified"  : "Fri Jun 12 23:03:50 JST 2015"
}
//}

ラーメン二郎歌舞伎町店の情報を参考に、大体このような感じでまとめてみました。
それぞれのキーの持つ意味については、次のようになります。


//table[key_description][API の戻り値に含まれる各キーの説明]{
キー									データ型					説明
-------------------------------------------------------------------------------
shop_name							String						店舗名
open									String						オフィシャル開店時間
last									String						オフィシャル閉店時間
regular_holiday				Array of String		定休日
address								Object						住所
address.prefecture		String						都道府県
address.city					String						市区町村
address.address1			String						住所1
address.address2			String						住所2
address.postal_code		String						郵便番号
menues								Array of Object 	メニュー
menues[].name					String						商品名
menues[].price				Integer						値段
estimation.buta       Float							ブタについての評価を表す値
estimation.men        Float							麺についての評価を表す値
estimation.soup       Float							スープについての評価を表す値
created								String						データ登録日（文字列表現）
modified							String						データ更新日（文字列表現）
//}

API の返すデータの設計はすなわち、二郎というものをどのように捉え、どう数値化するか
といった問題に対する答えとなります。
だれが見ても一意であるような情報である、住所やメニューといった情報をそのままデータ設計に落としこむのは簡単です。
問題となるのは、味わいの部分です。
もっと詳しくいうのであれば、麺の形状や茹で具合、当たり外れがあると言われるブタ（チャーシュー）の仕上がり、スープの仕上がりといった部分です。
これらをデータとして表現する場合、味について計測する標準的な手法がなく、個々人の感覚に頼った評価をしなくてはならないという点が問題になります。

ぐるなびなどを例にすると分かりやすいのですが、こういったものはレート制を導入するのがよくあるパターンでしょう。
主観的となる評価を一定の範囲内で点数として表してもらい、それを平均するなどした値を、味に対するユーザー全体の意見として利用します。

店ごとに存在するテイストはまた別に表現します。
たとえば、量について言えば、目黒店などはそれほど多くなく、神保町店などは逆にトップクラスに量が多いというのはよくいわれている話しです。
こういったものはコメントとして持たせておくようにします。

== ユーザ評価機能

ユーザによってその日のブレ具合や、総合的な評価の参考値となる値を投稿できるようにしたいと思います。
この値はログのように集積され、統計的な計算を行う上で用いられます。

estimation
  men
  buta
  soup

== API エラーの設計

エラーをどのように返すのが良いか。
HTTP のレスポンスコードと、それに含まれるコンテンツについて。


== 言語とミドルウェア

今回はフロントエンドは省いて Web API を提供するサーバサイドのプログラムのみを作成します。
API のアクセスのテストには wget を利用して、動作の例としようと思います。

== プログラミング言語の選択

実装にあたって利用する言語やミドルウェアですが、Go 言語を使ってみようと思います。
とくに戦略的な理由はありません。
ただ単に筆者が Go 言語で実装してみたかったというだけです。


== データベース

今回はデータベースのアーキテクチャとして KVS（Key Value Store：キーバリューストア）を採用したいと思います。
なぜかというと、著者が使ってみたかったからです。
というのは半分冗談ですで、今回はサービスの特性上妥当だと考えたからです。
本書で計画する Web API には各クライアントが共有するデータ、つまり厳密に整合性をとるべきデータというのが存在しません。
これはすなわちトランザクションというものを意識しなくても良いということでもあります。

分散型はデータの整合性を低くとるかわりに、スケーラビリティを高めやすいというのがその一つの特徴です。
本書においては特別スケーラビリティについて意識はしていませんが、
筆者の個人的な技術トライアウトという側面があるので気に入らなくてもかんべんしてください。


Go 言語にはちょうどいい具合に、シンプルな KVS の実装がいくつかあるようです。
さらりとググった中では、bolt というものと、golebeldb というものが引っかかりました。
まあこのあたりからチョイスすればいいんじゃないでしょうか。

boltdb/bolt
https://github.com/boltdb/bolt

Pure Go 言語の KVS 実装です。
Heroku といった著名なサービスのバックエンドでも利用されている実績があるらしい。
import するだけで使えるっぽいので素敵。


syndtr/goleveldb
https://github.com/syndtr/goleveldb

LevelDB（Google 製の KVS 実装）の Go 言語バインディング？
こちらも Pure Go な仕立てになっており、import するだけで使うことができると謳っている。




#@# http://qiita.com/umisama/items/c022b16101c48ffdbc6a
#@# 
#@# ==== database/sql
#@# 
#@# 言語は Go 言語で決めたということで、次はデータベースを選択してみましょう。
#@# まず、基本パッケージに含まれる database/sql というパッケージです。
#@# これは汎用的な SQL データベースアクセスのためのインターフェイスとして用意されているものです。
#@# SQL 文となる文字列を与えることで、SQL データベースとやりとりできます。
#@# 
#@# ==== `クエリビルダ`
#@# 
#@# もう一つはクエリビルダ（クエリジェネレータ）です。
#@# SQL 文の生成を Go 言語上の関数などの形となるよう抽象化したもので、
#@# 内部的に SQL 文を生成するような機能を持っています。
#@# 正しい SQL 文を生成してくれるという点において、生の SQL を手書きする場合とくらべてやや安全であるという利点があります。
#@# デメリットとしては、抽象化されているぶん細かい SQL がかけなくなってしまいます。
#@# 
#@# - squirrel
#@# - godoropbox/database/sqlbuilder
#@# 
#@# ==== ORM
#@# 
#@# Go 言語における ORM（Object Relational Mapper）、およびそれに近いといえるライブラリがいくつかあります。
#@# 
#@# - gorp https://github.com/coopernurse/gorp
#@# - genmai https://github.com/naoina/genmai
#@# - xorm https://github.com/go-xorm/xorm
#@# - gorm https://github.com/jinzhu/gorm


== HTTP サーバとルーティング

Go 言語の標準ライブラリには、HTTP サーバとしてプログラムを動作させるためのパッケージが含まれています。
今回はこれをそのまま使ってみたいと思います。

URL とサーバプログラム内にあるメソッドをマッピングするために用います。


== Bootstrapping

プログラムのひな形を作るにあたり https://github.com/tcnksm/gcli を利用させていただくことにします。
GoCon 2015 で紹介されていたので、乗っかってみましょう。
