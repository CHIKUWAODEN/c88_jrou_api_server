= 実装を考える

//read{
設計がみえてきたので、具体的なコードに落としこんでいきます。
今回は、Go言語と、適当なKVSを使ってみます。
あまり深い理由はなく、なんとなくGo言語で多少まともな形のコードを書いてみたかったのと、
なんとなくKVSというものにタッチしてみたかっただけです。
手段と目的があべこべな感じがしますが、まあ深くは気にしないようにしましょう。
//}


== goleveldb

本書で計画する Web API には各クライアントが厳密に整合性をとるべきデータというのが存在しません。
これはすなわちトランザクションというものを意識しなくても良いということでもあります。

分散型はデータの整合性を低くとるかわりに、スケーラビリティを高めやすいというのがその一つの特徴です。
（本書においては特別スケーラビリティについて意識するようなものではありませんが）

Go 言語にはちょうどいい具合に、シンプルな KVS の実装がいくつかあるようです。
さらりとググった中では、bolt というものと、@<href>{https://github.com/syndtr/goleveldb, syndtr/goleveldb} というものが引っかかりました。

今回はサンプルとREADMEがわかりやすかったgoleveldbをチョイスしました。
leveldbがGoogle由来の技術（？）であり、Go言語と合わせてGoogleで染めていこうかと思ったのも理由の一つです。


== HTTP サーバとルーティング

Go 言語の標準ライブラリには、HTTP サーバとしてプログラムを動作させるためのパッケージが含まれています。
今回はこれをそのまま使ってみたいと思います。


ルータは URL とサーバプログラム内にあるメソッドをマッピングするために用います。
Go 言語に標準的なルータの実装は無く、各種 Web 系のフレームワークに含まれていたり、
そこからフォークして作られたライブラリを使うのが一般的なようです。
今回はあまりルートの数が多くない（そんなに API が多くない）ので、文字列比較とか正規表現とかでゴリ押ししても良かったかもしれません。
まあライブラリを使った方がラクそうなので、今回は @<href>{github.com/julienschmidt/httprouter, httprouter}
というライブラリを使ってみることにします。
README.md を読んでみてドキュメンテーションの充実度とサンプルコードが分かりやすそうだったのが良かったです。

== コマンドラインオプションについて

== ソースコードのレイアウト

== 各種 API メソッドの実装例




#@# == エラー処理
